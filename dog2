import sys
import numpy as np
import csv
import plotly.offline
from plotly.graph_objs import Scatter, Layout, Figure
from plotly import tools
from multirank.dynkw import autoDynKWRupt

xkcd_colors = {}
with open('rgb.txt', 'r') as colors:
  for line in colors:
    if 'License' in line:
        continue
    name, color = line.split('#')
    name = name.strip()
    color = color.strip()
    xkcd_colors['xkcd:' + name] = '#' + color

colors = ['xkcd:red', 'xkcd:brown', 'xkcd:blue', 'xkcd:electric purple', 'xkcd:orange', 
          'xkcd:light blue', 'xkcd:teal', 'xkcd:magenta', 'xkcd:grey',
          'xkcd:turquoise', 'xkcd:cyan', 'xkcd:maroon',
          'xkcd:olive', 'xkcd:salmon', 'xkcd:beige', 'xkcd:navy blue', 'xkcd:black', 
          'xkcd:hot pink', 'xkcd:burnt yellow', 'xkcd:blue grey', 'xkcd:battleship grey', 'xkcd:pink', 'xkcd:yellow', 'xkcd:light purple']
colors_rgb = [xkcd_colors[color] for color in colors]

formats = ['lp', 'nl', 'bar', 'gms']

input = 'benchmarks/%s_branches_stats_history.csv' % sys.argv[2]

#
# Read input file
#
data = []
with open(input, 'r') as f:
    reader = csv.reader(f)
    for row in reader:
        data.append( row )
    # Read everything, including date

#
# Process data
#  
dates = []
info = {}

for row in data:
    date, python, branch, problem, fileformat, part, minval, meanval, maxval, stdval = row

    if meanval == "": # Don't count this round if meanval is empty
        continue
    if part != 'total': # Don't count this round if it isn't the total time part
        continue
    if python.endswith('-cython'):
        python = python[:-7]
        branch = branch + '-cython'

    if len(dates) == 0 or dates[-1] != date:
        dates.append( date )
        
    if not python in info:
        info[python] = {}
    if not problem in info[python]:
        info[python][problem] = {}
    if not fileformat in info[python][problem]:
        info[python][problem][fileformat] = {}
    if not branch in info[python][problem][fileformat]:
        info[python][problem][fileformat][branch] = {}
    # Another "Holy nested dictionaries, Batman" instance
    # Python, Problem, (nl, lp, etc.), Branch, Date = Mean of three runs
    info[python][problem][fileformat][branch][date] = float(meanval)
    
# We only use 23
#
# History Graphs for MASTER
#
# THIIIIS is the one we use
if sys.argv[1] == "23":
    formats = set()
    problems = set()
    results = {}
    lines = {}

    print("Running dog23 %s" % sys.argv[1])
    if len(dates) > 50:
        # Only do the most recent 50 historical pieces of info
        dates = dates[-50:]
    #
    def versiontuple(v):
        return tuple(map(int, (v.split("."))))
    _release_data = {}
    releases = {}
    # We're supposed to have some baseline release file stats. 
    # Not sure how this file is actually being generated.
    # It shows up in the workspace on Jenkins, but it's not being archived
    # Plus, it seems to get updated every run.
    fname = 'benchmarks/%s_releases_stats.csv' % sys.argv[2]
    with open(fname, 'r') as f:
        reader = csv.reader(f)
        for row in reader:
            _release_data[ tuple(row[1:6]) ] = row[6]
            #print(row[1:6], row[6])
            releases[ versiontuple(row[2]) ] = row[2]
    latest_version = releases[ sorted(releases.keys())[-1] ]
    devbranches = sys.argv[3:]
    print(devbranches)


    #
    # GRAPHS 1: Plotting against Python version
    #
    for python in info:

      print('Python:', python)
      print(50*'*')
      for problem in sorted(info[python].keys()):
        if 'quick' in problem: # Ignore the quick ones
            continue
        problems.add(problem)
        for fileformat in sorted(info[python][problem].keys()):
            formats.add(fileformat)
            #fig, ax = plt.subplots()
            line = 0

            print('Problem, format:', problem, fileformat)
            if 'master' not in list(info[python][problem][fileformat].keys()):
                continue
            traces = []
            _val = None
            _baseline = None
            _missing = True
            latest = None
            for branch in ['master'] + devbranches:  #sorted(info[python][problem][fileformat].keys()):

                i = 0
                y_ = []
                x_ = []
                for date in dates:
                    x_ = [i] + x_
                    if branch in info[python][problem][fileformat].keys():
                        y_.append( info[python][problem][fileformat][branch].get(date, None) )
                    else:
                        y_.append( None )
                    i -= 1

                traces.append( Scatter(x=x_, y=y_, mode='lines+markers', name=branch, text=dates) )
                lines[python, problem, fileformat, branch] = (x_, y_)

                if branch == 'master':
                    val = _release_data.get((python, latest_version, problem, fileformat, 'total'), None)
                    if val is not None:
                        if y_[-1] is not None:
                            _val = y_[-1]
                            _missing = False
                        _baseline = float(val)
                        val = _baseline
                        latest = Scatter(x=x_, y=[val]*len(x_), mode='lines', name="v"+latest_version)

            if latest is not None:
                traces.insert(0, latest)
            data = ( traces )

            xaxis = dict(
                        title="Latest Tests vs Current Release", 
                        tickmode="array", 
                        tickvals=x_, 
                        ticktext=[str(v) for v in x_],
                        showticklabels=True, 
                        )
            layout = Layout( 
                        title="Python=%s  Problem=%s  Fileformat=%s" % (python, problem, fileformat),
                        showlegend=True,
                        xaxis=xaxis,
                        yaxis=dict(title="Runtime (Seconds)") )
            fig = Figure(data=data, layout=layout)
            fname = "dog23_%s_%s_%s.html" % (python, problem, fileformat)
            results[python, problem, fileformat] = (fname, _val, _baseline, _missing)
            plotly.offline.plot( fig, filename='results/'+fname, auto_open=False )

    #
    # GRAPHS 2: Plotting against "problem" (bilinear, pmedian, etc.)
    #
    _formats = list(sorted(formats))
    _problems = list(sorted(problems))
    _python = list(sorted(info.keys()))
    results2 = {}
    for problem in _problems:
        
        print('Problem:', problem)
        print(50*'*')
        for fileformat in _formats:
            traces = []
            _val = {}
            _baseline = {}
            for python in _python:
                print('Python, format:', python, fileformat)
                x_, y_ = lines.get( (python, problem, fileformat, "master"), (None, None))
                _val[python] = None
                _baseline[python] = None
                if x_ is not None:
                    if y_[-1] is not None:
                        _val[python] = y_[-1]
                    val = _release_data.get((python, latest_version, problem, fileformat, 'total'), None)
                    if val is not None:
                        _baseline[python] = float(val)
                    traces.append( Scatter(x=x_, y=y_, mode='lines+markers', name=python, text=dates) )
            data = ( traces )

            fname = "dog23b_%s_%s.html" % (problem, fileformat)
            results2[problem, fileformat] = (fname, _val, _baseline, len(data) == 0)
            if len(data) > 0:
                xaxis = dict(
                            title="Latest Tests vs Current Release", 
                            tickmode="array", 
                            tickvals=x_, 
                            ticktext=[str(v) for v in x_],
                            showticklabels=True, 
                            )
                layout = Layout( 
                            title="Problem=%s  Fileformat=%s" % (problem, fileformat),
                            showlegend=True,
                            xaxis=xaxis,
                            yaxis=dict(title="Runtime (Seconds)") )
                fig = Figure(data=data, layout=layout)
                plotly.offline.plot( fig, filename='results/'+fname, auto_open=False )
    # #
    # # GRAPHS 3: Plot by File format
    # #
    # #TODO: THIS IS THE BROKEN PART
    # #
    # # Compute change points
    # #
    # ncp = {}
    # cp = {}
    # breaks = {}
    # ymin = {}
    # ymax = {}
    # for fileformat in _formats:
    #     print('Format:', fileformat)
    #     print(50*'*')
    #     for python in _python:
    #         ignore = set()
    #         vals_ = []
    #         ntraces = 0
    #         for problem in _problems:
    #             print('Python, problem:', python, problem)
    #             # Get the data for the Py/Prob/FF combo; replace with "None" if it doesn't exist
    #             x_, y_ = lines.get( (python, problem, fileformat, "master"), (None, None))
    #             # if the x coordinate is not None
    #             if x_ is not None:
    #                 v = [y for y in y_ if y is not None]
    #                 if len(v) != 0:
    #                     # Take the max/min of the y_ values, if they exist
    #                     ymax[python, fileformat, ntraces] = max(v)
    #                     ymin[python, fileformat, ntraces] = min(v)
    #                 # Number of points
    #                 npoints = len(y_)
    #                 for i in range(npoints):
    #                     if y_[i] is None:
    #                         # I'm not sure why we're doing this honestly
    #                         ignore.add(i)
    #                 vals_.append(y_)
    #                 ntraces += 1
    #         if len(data) == 0:
    #             print("WARNING: No plots for Python=%s FileFormat=%s" % (python, fileformat))
    #             continue
    #         #
    #         # Compute change points
    #         #
    #         print(("NPOINTS", npoints))
    #         print(("NIGNORE", len(ignore)))
    #         vals = np.zeros( (ntraces, npoints-len(ignore)) )
    #         breakmap = [None]*(npoints-len(ignore))
    #         for i, y_ in enumerate(vals_):
    #             k = 0
    #             for j, val in enumerate(y_):
    #                 if j not in ignore:
    #                     vals[i, k] = val
    #                     breakmap[k] = j
    #                     k += 1
    #         #print(vals)
    #         numCh, chP = autoDynKWRupt(vals)
    #         ncp[python, fileformat] = numCh
    #         print((python, fileformat))
    #         print(("numCh", numCh))
    #         breaks[python, fileformat] = []
    #         for i in range(numCh):
    #             breaks[python, fileformat].append( breakmap[chP[i]] )
    #             cp[breakmap[chP[i]]] = cp.get(breakmap[chP[i]], 0) + 1
    #             print((breakmap[chP[i]], breakmap[chP[i]]-49))
    # #
    # # Find the change points that are common across our python/fileformat statistical tests
    # #
    # tmp = list(sorted(cp.keys()))
    # common_cp = set()
    # for i in range(1,len(tmp)-1):
    #     if tmp[i-1] == tmp[i]-1 and tmp[i+1] == tmp[i]+1 and cp[tmp[i]] >=3 and cp[tmp[i]] > cp[tmp[i-1]] and cp[tmp[i]] > cp[tmp[i+1]]:
    #         print((tmp[i], tmp[i]-48.5, cp[tmp[i]]))
    #         common_cp.add(tmp[i])
    # #
    # # Now create the graph
    # #
    # for fileformat in _formats:
    #     for python in _python:
    #         traces = []
    #         for problem in _problems:
    #             x_, y_ = lines.get( (python, problem, fileformat, "master"), (None, None))
    #             if x_ is not None:
    #                 npoints = len(y_)
    #                 i = npoints-1
    #                 while i >= 0 and y_[i] is None:
    #                     i = i - 1
    #                 if i >= 0:
    #                     traces.append( Scatter(x=x_, y=y_, mode='lines+markers', name=problem, text=dates, marker=dict(color=colors_rgb[len(traces)]), line=dict(color=colors_rgb[len(traces)])) )
    #         data = ( traces )
    #         if len(data) == 0:
    #             print("WARNING: No plots for Python=%s FileFormat=%s" % (python, fileformat))
    #             continue
    #         #
    #         # Create graph
    #         #
    #         fig = tools.make_subplots(rows=len(traces), cols=1, shared_yaxes=False, shared_xaxes=True)
    #         for i in range(len(traces)):
    #             fig.append_trace( traces[i], i+1, 1 )
    #             for cp in common_cp:
    #                 color = 'black'
    #                 fig.append_trace( Scatter(x=[cp-48.5]*2, y=[ymin[python, fileformat, i], ymax[python, fileformat, i]], mode='lines', showlegend=False, line=dict(color=color, width=3)), i+1, 1 )
    #         fname = "dog23_stacked_%s_%s.html" % (fileformat, python)
    #         xaxis = dict(
    #                     title="Performance Relative to Current Performance", 
    #                     tickmode="array", 
    #                     tickvals=x_, 
    #                     ticktext=[str(v) for v in x_],
    #                     showticklabels=True, 
    #                     )
    #         fig['layout'].update(
    #                     title="Python=%s  Fileformat=%s" % (python, fileformat),
    #                     showlegend=True,
    #                     height=100*len(data))
    #                     #yaxis=dict(title="Runtime (Seconds)") )
    #                     #xaxis=xaxis)
    #         plotly.offline.plot( fig, filename='results/'+fname, auto_open=False )

    #
    # Create main file
    #
    with open("results/index.html", 'w') as OUTPUT:
        OUTPUT.write('<style type="text/css">\n')
        OUTPUT.write('a.dark:link { color: lightgrey; } a.dark:visited { color: lightgrey; }\n')
        OUTPUT.write('a.light:link { color: darkgrey; } a.light:visited { color: darkgrey; }\n')
        OUTPUT.write("tr, th { text-align: right; border: 1px solid black; border-collapse: collapse;}\n")
        OUTPUT.write("th.problem { text-align: left; border: 1px solid black; }\n")
        OUTPUT.write("th.python { text-align: center; border: 1px solid black; }\n")
        OUTPUT.write("th.gap { border: 1px white; }\n")
        OUTPUT.write("td { padding: 5px; }\n")
        OUTPUT.write("td.problem { text-align: left; border: 1px solid black; }\n")
        OUTPUT.write("td.missing_data { background-color: darkred; color: white; }\n")
        OUTPUT.write("td.no_baseline { background-color: red; }\n")
        OUTPUT.write("td.very_slow { background-color: gold; }\n")
        OUTPUT.write("td.slow { background-color: yellow; }\n")
        OUTPUT.write("td.ok { background-color: lightgreen; }\n")
        OUTPUT.write("td.fast { background-color: green; }\n")
        OUTPUT.write("td.very_fast { background-color: darkgreen; }\n")
        OUTPUT.write("td.none { background-color: black; }\n")
        OUTPUT.write("tr.gap { }\n")
        OUTPUT.write("</style>\n")
        OUTPUT.write("<h2>Pyomo Performance Comparisons: Writing Problem Files</h2>\n")
        # PYTHON
        OUTPUT.write("<hr>\n")

        #
        # TABLE 1
        #
        OUTPUT.write("<h3>Relative Performance Summary - Master</h3>\n")
        OUTPUT.write("<p>The following table describes the performance ratio for the runtime of the Pyomo master branch relative to the most recent Pyomo release.</p>\n")
        OUTPUT.write("<p>The table contains links to nightly performance for select branches of Pyomo.</p>\n")
        OUTPUT.write("<p>The runtime measure includes the time to generate a Pyomo model and write a problem file (in various formats).</p>\n")
        OUTPUT.write('<table>\n')
        # HEADER
        OUTPUT.write("<tr>\n")
        OUTPUT.write('<td></td>')
        nformats = len(_formats)
        for python in sorted(info.keys()):
            OUTPUT.write('<th class="gap"></th>')
            OUTPUT.write('<th colspan="{0}" class="python">{1}</th>'.format(nformats, python))
        OUTPUT.write("</tr>\n")
        # HEADER2
        OUTPUT.write("<tr>\n")
        OUTPUT.write('<th class="problem">Problem</th>')
        nformats = len(_formats)
        for python in info.keys():
            OUTPUT.write('<th class="gap"></th>')
            for f in _formats:
                OUTPUT.write('<th class="python">{0}</th>'.format(f))
        OUTPUT.write("</tr>\n")
        # PROBLEMS
        for problem in _problems:
            OUTPUT.write("<tr>\n")
            OUTPUT.write('<td class="problem">{0}</td>'.format(problem))
            for python in sorted(info.keys()):
                OUTPUT.write('<td class="gap"></td>')
                for f in _formats:
                    val = results.get( (python, problem, f), None)
                    if val is None:
                        OUTPUT.write('<td class="none"></td>')
                    else:
                        _url, _val, _baseline, _missing = val
                        if _missing:
                            OUTPUT.write('<td align="center" class="missing_data"><a class="dark" href="%s">NA</a></td>' % _url)
                        elif _baseline is None:
                            OUTPUT.write('<td align="center" class="no_baseline"><a class="dark" href="%s">X</a></td>' % _url)
                        else:
                            ratio = _val/_baseline
                            if ratio >= 1.10:
                                OUTPUT.write('<td align="center" class="very_slow"><a class="light" href="%s">%2.2f</a></td>' % (_url,ratio))
                            elif ratio >= 1.05:
                                OUTPUT.write('<td align="center" class="slow"><a class="light" href="%s">%2.2f</a></td>' % (_url,ratio))
                            elif ratio > 0.95:
                                OUTPUT.write('<td align="center" class="ok"><a class="light" href="%s">%2.2f</a></td>' % (_url,ratio))
                            elif ratio > 0.90:
                                OUTPUT.write('<td align="center" class="fast"><a class="dark" href="%s">%2.2f</a></td>' % (_url,ratio))
                            else:
                                OUTPUT.write('<td align="center" class="very_fast"><a class="dark" href="%s">%2.2f</a></td>' % (_url,ratio))
            OUTPUT.write("</tr>\n")
        OUTPUT.write("</table>\n")
        OUTPUT.write("<hr>\n")

        #
        # TABLE 2
        #
        OUTPUT.write("<h3>Absolute Performance Summary</h3>\n")
        OUTPUT.write("<p>The following table describes the runtime of the latest execution of the Pyomo master branch.</p>\n")
        OUTPUT.write("<p>The runtime measure includes the time to generate a Pyomo model and write a problem file (in various formats).</p>\n")
        OUTPUT.write('<table>\n')
        # HEADER
        OUTPUT.write("<tr>\n")
        OUTPUT.write('<td></td>')
        npython = len(info.keys())
        for f in _formats:
            OUTPUT.write('<th class="gap"></th>')
            OUTPUT.write('<th colspan="{0}" class="python">{1}</th>'.format(npython, f))
        OUTPUT.write("</tr>\n")
        # HEADER2
        OUTPUT.write("<tr>\n")
        OUTPUT.write('<th class="problem">Problem</th>')
        for f in _formats:
            OUTPUT.write('<th class="gap"></th>')
            for python in sorted(info.keys()):
                if python.startswith("python"):
                    _py = "py"+python[6:]
                else:
                    _py = python
                OUTPUT.write('<th class="python">{0}</th>'.format(_py))
        OUTPUT.write("</tr>\n")
        # PROBLEMS
        for problem in _problems:
            OUTPUT.write("<tr>\n")
            OUTPUT.write('<td class="problem">{0}</td>'.format(problem))
            for f in _formats:
                OUTPUT.write('<td class="gap"></td>')
                val = results2.get( (problem, f), None)
                for python in sorted(info.keys()):
                    if val is None:
                        OUTPUT.write('<td class="none"></td>')
                    else:
                        _url, _val, _baseline, _missing = val
                        _val = _val[python]
                        _baseline = _baseline[python]
                        if _missing:
                            OUTPUT.write('<td class="none"></td>')
                        elif _val is None:
                            OUTPUT.write('<td align="center" class="no_baseline"><a class="dark" href="%s">NA</a></td>' % _url)
                        elif _baseline is None:
                            OUTPUT.write('<td align="center" class="missing_data"><a class="dark" href="%s">%2.2f</a></td>' % (_url,_val))
                        else:
                            ratio = _val/_baseline
                            if ratio >= 1.10:
                                OUTPUT.write('<td align="right" class="very_slow"><a class="light" href="%s">%2.2f</a></td>' % (_url,_val))
                            elif ratio >= 1.05:
                                OUTPUT.write('<td align="right" class="slow"><a class="light" href="%s">%2.2f</a></td>' % (_url,_val))
                            elif ratio > 0.95:
                                OUTPUT.write('<td align="right" class="ok"><a class="light" href="%s">%2.2f</a></td>' % (_url,_val))
                            elif ratio > 0.90:
                                OUTPUT.write('<td align="right" class="fast"><a class="dark" href="%s">%2.2f</a></td>' % (_url,_val))
                            else:
                                OUTPUT.write('<td align="right" class="very_fast"><a class="dark" href="%s">%2.2f</a></td>' % (_url,_val))
            OUTPUT.write("</tr>\n")
        OUTPUT.write("</table>\n")
        OUTPUT.write("<hr>\n")

        #
        # Relative Graph
        #
        if False:
            OUTPUT.write("<h3>Relative Performance Trends</h3>\n")
            OUTPUT.write("<p>The following graph shows the performance trends relative to the runtime of the latest execution of the Pyomo master branch.</p>\n")
            OUTPUT.write("<p>The runtime measure includes the time to generate a Pyomo model and write a problem file (in various formats).</p>\n")
            OUTPUT.write("<p></p>\n")
            OUTPUT.write('<table>\n')
            # HEADER
            OUTPUT.write("<tr>\n")
            OUTPUT.write('<td></td>')
            for fileformat in _formats:
                OUTPUT.write('<td class="python">%s</td>' % fileformat)
            OUTPUT.write("</tr>\n")
            # FILE FORMATS
            for python in _python:
                OUTPUT.write('<td align="left" class="problem">%s</td>' % python)
                for fileformat in _formats:
                    OUTPUT.write('<td class="very_fast"><a align="center" href="dog23_relative_%s_%s.html">___</a></td>' % (fileformat, python))
                OUTPUT.write("</tr>\n")
            OUTPUT.write("</table>\n")
            OUTPUT.write("<hr>\n")

        #
        # Stacked Graphs
        #
        OUTPUT.write("<h3>Performance Trends</h3>\n")
        OUTPUT.write("<p>The following graphs show the performance trends for Pyomo on each test problem.  The number in the table below is the number of statistical changepoints detected across Pyomo's performance for a python-fileformat pair.</p>\n")
        OUTPUT.write("<p>The runtime measure includes the time to generate a Pyomo model and write a problem file (in various formats).</p>\n")
        OUTPUT.write("<p></p>\n")
        OUTPUT.write('<table>\n')
        # HEADER
        OUTPUT.write("<tr>\n")
        OUTPUT.write('<td></td>')
        for fileformat in _formats:
            OUTPUT.write('<th class="python">%s</th>' % fileformat)
        OUTPUT.write("</tr>\n")
        # FILE FORMATS
        for python in _python:
            OUTPUT.write('<td align="left" class="problem">%s</td>' % python)
            for fileformat in _formats:
                OUTPUT.write('<td class="very_fast"><a class="dark" href="dog23_stacked_%s_%s.html">___</a></td>' % (fileformat, python))
            OUTPUT.write("</tr>\n")
        OUTPUT.write("</table>\n")
        OUTPUT.write("<hr>\n")

        OUTPUT.write("</body></html>\n")
